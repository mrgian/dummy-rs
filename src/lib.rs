#![allow(warnings)]
#![feature(pointer_byte_offsets)]
#![feature(ptr_sub_ptr)]

use const_format::formatcp;
use hex_literal::hex;
use std::error::Error;
use std::ffi::*;
use dbgtools_hexdump::{hexdump, Config};
use rand::Rng;

mod bindings;
use bindings::*;

mod plugin;
use plugin::{Common, Event, Extract, Plugin, Source};

mod macros;

#[derive(Debug)]
struct DummyState {
    sample_num: u64,
    remaining_events: u32,
    last_error: String,
    string_storage: String,
}

const dummy: Plugin = Plugin {
    name: "dummy-rs",
    description: "Falco dummy plugin written in Rust",
    contact: "Gianmatteo Palmieri <mail@gian.im>",
    version: "0.0.0",
    required_api_version: "3.0.0",
    event_source: "dummy-rs-source",
    id: 999,
};

static mut nevents: i32 = 0;

plugin_common!(dummy);
plugin_source!(dummy);
plugin_extract!(dummy);

impl Common for Plugin<'_> {
    fn init(&self) -> Box<DummyState> {
        println!("Initializing plugin...");

        let state = Box::new(DummyState {
            sample_num: 0,
            remaining_events: 10, //generate 10 events
            last_error: "".to_string(),
            string_storage: "".to_string(),
        });

        state
    }

    fn destroy(&self, state: &mut DummyState) {
        println!("Destroying plugin...");
    }
}

impl Source for Plugin<'_> {
    fn open(&self, state: &mut DummyState) -> Result<(), String> {
        println!("Opening event stream...");

        //Err("Error while opening")
        Ok(())
    }

    fn close(&self, state: &mut DummyState) {
        println!("Closing event stream...");
    }

    fn next_batch(&self, state: &mut DummyState) -> Result<i32, String> {
        //setting num field to a random number, just to demonstrate you can get this form the state later
        let mut rng = rand::thread_rng();
        state.sample_num = rng.gen::<u64>();

        //generate 10 events
        if state.remaining_events == 0 {
            return Ok(-1); //SS_PLUGIN_TIMEOUT
        }

        state.remaining_events -= 1;

        Ok(0) //SS_PLUGIN_SUCCESS
    }
}

const fields_schema: &str = r#"
[
    {"type": "string","name": "sample.hello","desc": "An hello string"},
    {"type": "string","name": "sample.num","desc": "A random number generated by the event"}
]
"#;
const FIELDS_SCHEMA: &str = formatcp!("{}\0", fields_schema);

//const hello_field: &str = "Hello field!\0";

impl Extract for Plugin<'_> {
    fn get_fields(&self) -> &str {
        FIELDS_SCHEMA
    }

    fn extract_fields(&self, state: &mut DummyState, fields: &mut [ss_plugin_extract_field]) -> Result<(), String> {
        //get sample num from state
        state.string_storage = format!("Hello field! Sample num: {}\0", state.sample_num);

        //let mut hello_ptr = "Hello field!\0".as_ptr() as *const ::std::os::raw::c_char;
        let mut hello_ptr = state.string_storage.as_ptr() as *const ::std::os::raw::c_char;
        fields[0].res.str_ = &mut hello_ptr as *mut *const ::std::os::raw::c_char;
        fields[0].res_len = 1;

        //NOTE: i still don't know why num_fields is 1 even if the field count is 2
        /*let sample_num_ptr = &mut state.sample_num as *mut u64;
        fields[1].res.u64_ = sample_num_ptr;
        fields[1].res_len = 1;*/

        Ok(())
    }
}
